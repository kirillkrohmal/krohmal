Реализовать коллекцию SimpleSet. Коллекция должна обеспечивать void add(E e) и реализовывать Iterator<E>.
Коллекция не должна хранить дубликаты.
Set - внутри для хранения данных использует обычные массивы.

* в коде есть ошибки:
* 1) необходимо инициализировать поле value
* 2) в методе add поле size не инкрементируется, в итоге элемент всегда будет вставляться по индексу 0 +
* нужна проверка выхода за границы массива
* 3) также метод add должен проверять нет ли таких элементов, потому что set не допускает дубликатов
* 4) методы hasNext должен проверять есть ли элементы в сетке
* 5) метод next должен возвращать следующий элемент, либо кидать NoSuchElementException
* тебе надо проверить. что в массиве нет такого элемента.


* в методе next E o = (E) new Object(); - это лишнее
* метод next должен возвращать следующий элемент, либо кидать NoSuchElementException
* o = (E) value[size++]; - это неправильно. Ведь size указывает сколько элементов добавлено.

* 1) Почему в методе hasNext e = (E) value[size] ? Ты же должен проверять есть ли элементы, а что делает эта
* строка? 2) Зачем в методе next elem[size++] = e; У тебя же elem это массив, причем не инициализированный, а
* ты еще присваиваешь ему значение. 3) return (E) elem - как массив можно приводить к типу элемента?

1) почему в конструкторе SimpleSet (Object[] value, int size) указывается size, ты же его инкрементируешь при добавлении,
по факту это  у тебя счетчик элементов, а ты передаешь его в конструктор в качестве аргумента.
2) чтобы увеличить массив нужно записывать вот так value = Arrays.copyOf(value, value.length * 2); - потому что метод
copyOf возвращает копию массива новой длины.
3) почему в методе isDuplicate не передается элемент для поиска. Тебе же надо сравнивать с чем-то.
4) в методе isDuplicate при нахождении дубликата есть смысл прерывать цикл, зачем продолжать поиск после нахождения
дубликата.
5) зачем в методе hasNext поиск дубликата?

1) в методе hasNext вот такая строка if (contains(e)) ? Это ведь не имеет никакого смысла.
2) зачем вот это строка в методе next E[] elem = (E[]) value[counter] ? Такое приведение не верно.
3) Вот это строка тоже не верна value[counter++] = i;

