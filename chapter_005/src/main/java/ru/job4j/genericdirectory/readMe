Реализовать собственную структуру данных - HashMap [#1008]

Ассоциативный массив на базе хэш-таблицы должен быть унифицирован через генерики и иметь методы:
boolean insert(K key, V value);
V get(K key);
boolean delete(K key);

Реализовывать итератор
Внутренняя реализация должна использовать массив. Нужно обеспечить фиксированное время вставки и получение. Предусмотрите
возможность роста хэш-таблицы при нехватке места для нового элемента.
Методы разрешения коллизий реализовывать не надо. Например: если при добавлении ключ уже есть, то возвращать false.

Это задание похоже на сет на базе хэш-таблиц, только сохраняешь не отдельные элементы, а пары ключ-значение.

private int getHashCodeKey (K key) {
    int result = Arrays.hashCode(entry);
    result = 31 * result + size;
    return result;
}
этот метод абсолютно неверный. Объясни, что он делает и подумай почему он неправильный.

Пары ключ-значения хранятся по индексам вычисляемым через хэш-сумму ключа.
Если ячейка по указанному индексу пуста - добавляй элемент, иначе не добавляешь.

метод insert работает правильно, но проверки внутри блока if дублируют друг друга:

if (entry[index] == null && contains(value)), а метод contains делает следующее
entry[indexOf(value)] == null, т.е. тоже самое как и первая часть if блока.
Зачем такое дублирование? Нужно удалить одну из дублирующих проверок.

Метод get реализован не верно. Ты перебираешь все элементы массива в поисках совпадения, а это не эффективно.
Вспомни, что преимущество хэш-таблиц в константном времени доступа О(1), а твоя реализация деградирует до O(n).
Метод get должен получив ключ вычислить индекс массива куда пара ключ-значение с таким ключом могла бы быть помещена,
и соответственно в той ячейке проверяй - есть значение или нет.

Нет, неверно. Задача метода вернуть объект value, хранимый по индексу вычисляемому на основе хэша ключа.
А у тебя внутри if'а проверяется если ячейка пуста, ты зачем-то создаешь новый Entry и помещаешь по этому адресу.
Какой смысл? Тебе же не сохранять надо, а проверить есть или нет, и если есть то вернуть value иначе можешь вернуть null.

Кирилл, ты пишешь K key = (K) stock.getKey(); - ну сам подумай, чтобы переменная указывала на объект, ей нужно
присвоить какое-то значение (ссылку на объект в памяти). А у тебя stock на что указывает? Попробуй вызвать метод
на не инициализированной переменной, к чему это приведет?

у тебя есть массив, в нем часть ячеек заняты, часть нет. Поэтому тебе надо в цикле проходить по массиву с самого начала,
и проверять null или нет. Если нашел не null, то останавливаешься запоминаешь индекс и возвращаешь true, а уже в методе
next возвращаешь элемент хранимых по указанному индексу.



а зачем перезаписывать данные в массиве? А если к примеру в этой ячейке хранилось какое-то значение, тогда такой вызов
приведет к тому, что значение в ней будет заменено на другое. В итоге старое значение потеряется. Какой в этом смысл?
Итератор же возвращает хранимые в коллекции элементы, а у тебя получается вызов итератора может привести к тому,
что часть хранимых в коллекции значений будет потеряно.

Раз ты используешь counter как указатель на следующий элемент, то тебе нужно присваивать ему значение, но не элементу массива.
 Надо писать counter = i;, тогда индекс найденного элемента будет сохранен в counter, а последующий вызов next вернет элемент
 хранимый по указанному индексу. И после строки isPresent = true; надо обязательно ставить break. Иначе цикл продолжит
 выполняться.

if (entry[size] != null) {            --> это условие тебе не нужно, оно не имеет смысла. Удали его.
    isPresent = true;
}

for (int i = 0; i < entry.length; i++) - такое условие не подходит, потому что при каждом вызове метода hasNext он
будет искать не null элементы с самого начала, а тебе надо чтобы он продолжал поиск начиная с элемента следующего за
тем элементом, который был возвращен методом next. Поэтому i должно инициализироваться не 0, а counter.