Каким образом можно обеспечить увеличение скорости вставки объекта в коллекцию типа Set?
1. Продемонстрировать данное решение.
2. Сравните производительность двух решений до и после оптимизации.
3. В задании надо написать код и проставить время выполнение на одинаковых выборках.


Напишите свою реализацию Set на базе хэш-таблицы. Реализуйте следующие методы:
1) boolean add (E e)
2) boolean contains (E e)
3) boolean remove (E e)


1) В методе add цикл for не нужен. Надо проверить есть ли такой элемент в сете, если нет то добавить.
2) Массив надо инициализировать.
3) Удаляешь вычисляя индекс и зануляя. 4) для сего метод equals и hashCode?

Кирилл, ты код переписал заново? Он не верный.

Начнем с метода add - зачем строка if (indexOf(e) != key && !objects[size].equals(e)). Ты сравниваешь получаемый индекс с key -
но это не имеет никакого смысла. Почему они должны быть равны или не равны?
И зачем сравнивать objects[size].equals(e)? У тебя элементы вставляются последовательно (у тебя вот такая строка objects[size++] = e)
(что в принципе не верно), а  size указывает на следующую ячейку куда надо вставить, т.о. она у тебя пустая, а у нее вызывается метод
equals. Тебе надо в методе add вызывать contains, и если такого элемента нет, то добавлять по указанному индексу.
Сам метод contains надо переписать.  Посмотри на строку while (objects[indexOf(e)] != null). Этот цикл будет исполняться пока
указанная ячейка не null, но если хранимый элемент не совпадет с переданным параметром, то у тебя постоянно программа будет крутиться
в цикле и инкремент поля size никак тут не помогает. Здесь сделай упрощенно: если ячейка по указанному индексу пуста (null),
то возвращай false, иначе возвращай true.
Поправь пока эти методы, потом дальше разберем.

Кирилл, if (e != null && getKey() == key) getKey возвращает key и сравнивает с key, разве они могут быть не равны?
К чему такое сравнение?

objects[indexOf(e)] = e; - вместо удаления элемента, ты его сохраняешь. А дальше e = null; - e это у тебя аргумент,
ты обнуляешь ссылку на аргумент, а надо хранимое в коллекции значение.