Реализовать класс с методом Iterator<Integer> convert(Iterator<Iterator<Integer>> it).

Что из себя представляет запись Iterator<Iterator<Integer>?.

Каждый итератор это последовательность.

Итератор 1 – 4 2 0 4 6 4 9

Итератор 2 – 0 9 8 7 5

Итератор 3 – 1 3 5 6 7 0 9 8 4

Если мы говорим о записи Итератор Итераторов. Значит итератор содержит не конечные значения, а сложенные итераторы.

Итератор - Итератор 1, Итератор 2, Итератор 3.

Метод convert должен принимать объект итератор итератор и возвращать Итератор чисел.

Iterator<Iterator<Integer> - ((4 2 0 4 6 4 9), (0 9 8 7 5), (1 3 5 6 7 0 9 8 4))

Метод должен возвращать

Iterator<Integer> - (4 2 0 4 6 4 9 0 9 8 7 5 1 3 5 6 7 0 9 8 4)

Метод не должен копировать данные. Нужно реализовать итератор, который будет пробегать по вложенными итераторам
без копирования данных.

Пример.

public class Converter {
   Iterator<Integer> convert(Iterator<Iterator<Integer>> it) {
      return new Iterator<Integer>() {
        @Override
        public boolean hasNext() {
           return false;
        }

        @Override
        public Integer next() {
           return null;
        }
     };
   }
}

public class ConverterTest {
    @Test
    public void whenItHasTwoInnerIt() {
        Iterator<Iterator<Integer>> it = Arrays.asList(
            Collections.singletonList(1).iterator(),
            Collections.singletonList(2).iterator()
        ).iterator();
       Iterator<Integer> convert = new Converter().convert(it);
       convert.next();
       int result = convert.next();
       assertThat(result, is(2));
    }
}

По сути логика такая - есть несколько итераторов, надо написать один суммирующий их, но при этом не создавать новый.
Т.е. должны быть методы hasnext(), next() и что-нибудь типа selectIterator(), в котором бы осуществлялся выбор
следующего итератора по условию.