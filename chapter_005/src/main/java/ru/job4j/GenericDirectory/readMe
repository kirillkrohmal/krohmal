Реализовать собственную структуру данных - HashMap [#1008]

Ассоциативный массив на базе хэш-таблицы должен быть унифицирован через генерики и иметь методы:
boolean insert(K key, V value);
V get(K key);
boolean delete(K key);

Реализовывать итератор
Внутренняя реализация должна использовать массив. Нужно обеспечить фиксированное время вставки и получение. Предусмотрите
возможность роста хэш-таблицы при нехватке места для нового элемента.
Методы разрешения коллизий реализовывать не надо. Например: если при добавлении ключ уже есть, то возвращать false.

Это задание похоже на сет на базе хэш-таблиц, только сохраняешь не отдельные элементы, а пары ключ-значение.

private int getHashCodeKey (K key) {
    int result = Arrays.hashCode(entry);
    result = 31 * result + size;
    return result;
}
этот метод абсолютно неверный. Объясни, что он делает и подумай почему он неправильный.

Пары ключ-значения хранятся по индексам вычисляемым через хэш-сумму ключа.
Если ячейка по указанному индексу пуста - добавляй элемент, иначе не добавляешь.

метод insert работает правильно, но проверки внутри блока if дублируют друг друга:

if (entry[index] == null && contains(value)), а метод contains делает следующее
entry[indexOf(value)] == null, т.е. тоже самое как и первая часть if блока.
Зачем такое дублирование? Нужно удалить одну из дублирующих проверок.

Метод get реализован не верно. Ты перебираешь все элементы массива в поисках совпадения, а это не эффективно.
Вспомни, что преимущество хэш-таблиц в константном времени доступа О(1), а твоя реализация деградирует до O(n).
Метод get должен получив ключ вычислить индекс массива куда пара ключ-значение с таким ключом могла бы быть помещена,
и соответственно в той ячейке проверяй - есть значение или нет.

Нет, неверно. Задача метода вернуть объект value, хранимый по индексу вычисляемому на основе хэша ключа.
А у тебя внутри if'а проверяется если ячейка пуста, ты зачем-то создаешь новый Entry и помещаешь по этому адресу.
Какой смысл? Тебе же не сохранять надо, а проверить есть или нет, и если есть то вернуть value иначе можешь вернуть null.

Кирилл, ты пишешь K key = (K) stock.getKey(); - ну сам подумай, чтобы переменная указывала на объект, ей нужно
присвоить какое-то значение (ссылку на объект в памяти). А у тебя stock на что указывает? Попробуй вызвать метод
на не инициализированной переменной, к чему это приведет?

у тебя есть массив, в нем часть ячеек заняты, часть нет. Поэтому тебе надо в цикле проходить по массиву с самого начала,
и проверять null или нет. Если нашел не null, то останавливаешься запоминаешь индекс и возвращаешь true, а уже в методе
next возвращаешь элемент хранимых по указанному индексу.